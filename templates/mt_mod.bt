//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: mt_mod.bt
//   Authors: TGE 
//   Credits: Lukas Cone (MT Framework Import Tool)
//            UberGrainy (format notes)
//          
//   Version: 0.1
//   Purpose: Parse MT framework MOD files
//  Category: 3D Model files
// File Mask: *.mod
//  ID Bytes: 4D4F4400
//   History: 
//------------------------------------------------

#include "mt_shared.bt"

typedef struct
{
    u32 JointIndex : 12;
    u32 MaterialIndex : 12;
    u32 LodIndex : 8;
} rModelMaterialIndices;

//typedef struct
//{
//    /* 00 */ rModelCmpFloatS16 Vertices[3];
//    /* 06 */ rModelCmpFloatS16 BoneWeight;
//    /* 08 */ rModelCmpFloatS8 Normals[4];
//    /* 0C */ rModelCmpFloatS8 Tangent[2];
//    /* 0E */ rModelCmpFloatS8 Binormal[2];
//    /* 10 */ rModelCmpFloatF16 UV1[2];
//    /* 14 */ rModelCmpFloatF16 BoneIndices[2];
//} rModelVertex_IASkinTB2wt;

typedef struct
{
    /* 00 */ u16 Type;
    /* 02 */ u16 VertexCount;
    /* 04 */ rModelMaterialIndices Indices;
    ///* 07 */ u8 LodIndex; // 0=null, 1=high, 2=mid, 3=low,FF=shadow
    /* 08 */ u8 Category1; // flags? 0x9=hidden, 0x11=hands, 0x21=visible
    /* 09 */ u8 Category2; // cont.
    /* 0A */ u8 VertexStride; 
    /* 0B */ u8 RenderMode;
    /* 0C */ u32 VertexStartIndex;      // index of the starting vertex in the buffer slice 
    /* 10 */ u32 VertexBufferOffset;    // offset into the model vertex buffer
    /* 14 */ rShaderObjectId Shader;    // shader name crc << 12 | shader index
    /* 18 */ u32 IndexBufferOffset;     // offset into the model index buffer, in multiples of 2
    /* 1C */ u32 IndexCount;            // number of indices to render
    /* 20 */ u32 IndexStartIndex;       // index of the starting index in the buffer slice
    /* 24 */ u8 BoneIdStart;
    /* 25 */ u8 PrimitiveJointLinkIdx;
    /* 26 */ u16 Index;                 // overwritten at load
                                        // becomes index of unique primitive (same vertex format etc)
    /* 28 */ u16 MinVertexIndex;        // lowest vertex triangle index in buffer
    /* 2A */ u16 MaxVertexIndex;        // highest vertex index in buffer
    /* 2C */ u32 Field2C;
    /* 30 */ u32 PrimitiveJointLinkPtr;  // overwritten at load
    /* 34 */ u32 Field34;

    local u64 p = FTell();
    FSeek( File.Header.VertexBufferOffset.Value + VertexBufferOffset );
    ReadVertexBuffer( (rShaderObjectHash)Shader.Hash, VertexCount );

    FSeek( File.Header.IndexBufferOffset.Value + ( IndexBufferOffset * 2 ) );
    u16 IndexBuffer[ IndexCount ];

    FSeek( p );
} rModelPrimitive <bgcolor=0x9c171d, optimize=false>;


typedef struct
{
    u32 Field00;
    u32 Field04;
    u32 Field08;
    u32 Field0C;
    f32 Field10;
    f32 Field14;
    f32 Field18;
    f32 Field1C;
} rModelGroup <bgcolor=0x254cae>;

// size = 0x18
typedef struct
{
    /* 00 */ u8 No; // mNo, id of the joint
    /* 01 */ u8 Parent; // mParent
    /* 02 */ u8 Symmetry; // mSymmetry, index to opposite joint
    /* 03 */ u8 Field03; // unused (?)
    /* 04 */ f32 Field04; // unused (?)
    /* 08 */ f32 Length; // mLength, distance to parent bone
    /* 0C */ SVec3 Offset; // mOffset, relative to parent
    // Assert( Field03 == 0 );
} rModelJoint <bgcolor=0x14c2e9>;

typedef struct
{
    u8 Name[128];   
} rModelMaterial <bgcolor=0x447e49>;

// size = 0x90
typedef struct
{
    /* 00 */ u32 JointIdx;
    /* 04 */ u32 Field04;
    /* 08 */ u32 Field08;
    /* 0C */ u32 Field0C;
    /* 10 */ SVec4 BoundingSphere;
    /* 20 */ SVec4 Min;
    /* 30 */ SVec4 Max;
    /* 40 */ SMtx44 LocalMtx;
    /* 80 */ SVec4 Field80;
} rModelPrimitiveJointLink <bgcolor=0xbcdd3f>;

typedef struct
{
    u32 Magic;
    u16 Version;
    u16 JointCount; // bone count
    u16 PrimitiveCount; // mesh count
    u16 MaterialCount; 
    u32 VertexCount;
    u32 IndexCount; // face count
    u32 PolygonCount; // vertex ids, "number of triangles excluding non-planar edge geometry"
    u32 VertexBufferSize;
    u32 SecondBufferSize;
    SNativeInt GroupCount; // group count
    SNativeInt JointsOffset; // bone offset
    SNativeInt GroupOffset; // group offset
    SNativeInt MaterialsOffset; // texture offset
    SNativeInt PrimitiveOffset; // mesh offset
    SNativeInt VertexBufferOffset; 
    SNativeInt IndexBufferOffset;
    SNativeInt ExDataOffset;
    SSphere BoundingSphere;
    SBoundingBox BoundingBox;
    u32 Field90; // 1000, id?
    u32 Field94; // 3000
    u32 Field98; // 1, layer info?
    u32 Field9C; // 0
    u32 PrimitiveJointLinkCount;
} rModelHeader <bgcolor=0x0177e2>;

typedef struct
{
    local u64 p = FTell();
    rModelHeader Header;

    FSeek( p + Header.JointsOffset.Value );
    rModelJoint Joints[Header.JointCount];
    SMtx44 JointLocalMtx[Header.JointCount]; // ?
    SMtx44 JointWorldMtx[Header.JointCount]; // ?
    byte BoneMap[256];

    FSeek( p + Header.GroupOffset.Value );
    rModelGroup Groups[Header.GroupCount.Value];

    FSeek( p + Header.MaterialsOffset.Value );
    rModelMaterial Materials[Header.MaterialCount];

    FSeek( p + Header.PrimitiveOffset.Value );
    rModelPrimitive Primitives[Header.PrimitiveCount];
    rModelPrimitiveJointLink PrimitiveJointLinks[Header.PrimitiveJointLinkCount];

    FSeek( p + Header.VertexBufferOffset.Value );
    byte VertexBuffer[ Header.VertexBufferSize ] <bgcolor=0x17e9aa>;

    // always 2 bytes
    FSeek( p + Header.IndexBufferOffset.Value );
    ushort IndexBuffer[ Header.IndexCount ] <bgcolor=0xf8c956>;

    FSeek( p + Header.ExDataOffset.Value );
    u32 ExDataPresent;
    if ( ExDataPresent )
    {
        // based on the code, havent seen it in files yet
        u16 ExCount1;
        u16 ExCount2;
        u32 ExPrimValues[Header.PrimitiveCount];
        u32 ExVertexBufferSize;
        u8 ExVertexBuffer[ExVertexBufferSize];
        u32 ExVertexBuffer2Size;
        u8 ExVertexBuffer2[ExVertexBuffer2Size];
    }
} rModel <bgcolor=0xb33057>;

rModel File;