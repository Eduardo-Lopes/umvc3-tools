//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: mt_mod.bt
//   Authors: TGE 
//   Credits: Lukas Cone (MT Framework Import Tool)
//            UberGrainy (format notes)
//          
//   Version: 0.1
//   Purpose: Parse MT framework MOD files
//  Category: 3D Model files
// File Mask: *.mod
//  ID Bytes: 4D4F4400
//   History: 
//------------------------------------------------

#include "mt_shared.bt"

typedef struct
{
    // ex. 010000FF (bytes)
    /* FFF00000 */ u32 JointIndex : 12;        // root joint index
    /* 000FFF00 */ u32 MaterialIndex : 12;     // index into the material name array
    /* 000000FF */ u32 LodIndex : 8;           // 0=null, 1=high, 2=mid, 3=low,FF=shadow
} rModelJointMaterialLodId;

typedef struct
{
    /* 00 */ u16 Type;                          // ?
    /* 02 */ u16 VertexCount;                   // no. of vertices drawn by this primitive
    /* 04 */ rModelJointMaterialLodId JMLId;    // aggregrate of root joint index, material index and lod index
    /* 08 */ u8 Category1;                      // flags? 0x9=hidden, 0x11=hands, 0x21=visible
    /* 09 */ u8 Category2;                      // cont.
    /* 0A */ u8 VertexStride;                   // no. bytes per vertex
    /* 0B */ u8 RenderMode;                     // ?
    /* 0C */ u32 VertexStartIndex;              // index of the starting vertex in the buffer slice 
    /* 10 */ u32 VertexBufferOffset;            // offset into the model vertex buffer
    /* 14 */ rShaderObjectId Shader;            // shader name crc << 12 | shader index
    /* 18 */ u32 IndexBufferOffset;             // offset into the model index buffer, in multiples of 2
    /* 1C */ u32 IndexCount;                    // number of indices to render
    /* 20 */ u32 IndexStartIndex;               // index of the starting index in the buffer slice
    /* 24 */ u8 BoneMapStartIndex;              // starting index used for the bone idx -> joint idx map
    /* 25 */ u8 PrimitiveJointLinkCount;        // no. prim joint links used by this primitive
    /* 26 */ u16 Index;                         // base 1 unique primitive index; overwritten at load
                                                // becomes index of unique primitive (same vertex format etc)
    /* 28 */ u16 MinVertexIndex;                // lowest vertex triangle index in buffer
    /* 2A */ u16 MaxVertexIndex;                // highest vertex index in buffer
    /* 2C */ u32 Field2C;                       // ?; always 0 for Ryu
    /* 30 */ u64 PrimitiveJointLinkPtr;         // overwritten at load

    local u64 p = FTell();
    FSeek( File.Header.VertexBufferOffset.Value + VertexBufferOffset );
    //ReadVertexBuffer( (rShaderObjectHash)Shader.Hash, VertexCount );

    local u64 relIndexBufferOffset = IndexBufferOffset + IndexStartIndex;
    FSeek( File.Header.IndexBufferOffset.Value + ( relIndexBufferOffset * 2 ) );
    u16 IndexBuffer[ IndexCount ];

    //Printf( "%d\n", Type );
    //Printf( "%08X\n", Type );
    //Printf( "%d\n", Category2 );
    //Printf( "%d\n", RenderMode );
    //Printf( "%d\n", Field2C );

    FSeek( p );
} rModelPrimitive <bgcolor=0x9c171d, optimize=false>;


typedef struct
{
    u32 Field00;
    u32 Field04; // always 0 for Ryu
    u32 Field08; // always 0 for Ryu
    u32 Field0C; // always 0 for Ryu
    f32 Field10;
    f32 Field14;
    f32 Field18;
    f32 Field1C;

    //Printf( "Field00: %d\n", Field00 );
    //Printf( "Field10: %d\n", Field10 );
} rModelGroup <bgcolor=0x254cae, optimize=true>;

// size = 0x18
typedef struct
{
    /* 00 */ u8 No; // mNo, id of the joint
    /* 01 */ u8 Parent; // mParent
    /* 02 */ u8 Symmetry; // mSymmetry, index to opposite joint
    /* 03 */ u8 Field03; // always 0 for Ryu
    /* 04 */ f32 Field04; // unused (?)
    /* 08 */ f32 Length; // mLength, distance to parent bone
    /* 0C */ SVec3 Offset; // mOffset, relative to parent
} rModelJoint <bgcolor=0x14c2e9, optimize=true>;

typedef struct
{
    u8 Name[128];   
} rModelMaterial <bgcolor=0x447e49>;

// size = 0x90
typedef struct
{
    /* 00 */ u32 JointIdx;
    /* 04 */ u32 Field04;
    /* 08 */ u32 Field08;
    /* 0C */ u32 Field0C;
    /* 10 */ SVec4 Vec10;
    /* 20 */ SVec4 Vec20;
    /* 30 */ SVec4 Vec30;
    /* 40 */ SMtx44 Mtx40;
    /* 80 */ SVec4 Vec80;
    //Printf( "jointIdx: %d\n", JointIdx );
} rModelPrimitiveJointLink <bgcolor=0xbcdd3f, optimize=true>;

typedef struct
{
    u32 Magic;
    u16 Version;
    u16 JointCount; // bone count
    u16 PrimitiveCount; // mesh count
    u16 MaterialCount; 
    u32 VertexCount;
    u32 IndexCount; // face count
    u32 PolygonCount; // vertex ids, "number of triangles excluding non-planar edge geometry"
    u32 VertexBufferSize;
    u32 VertexBuffer2Size;
    SNativeInt GroupCount; // group count
    SNativeInt JointsOffset; // bone offset
    SNativeInt GroupOffset; // group offset
    SNativeInt MaterialsOffset; // texture offset
    SNativeInt PrimitiveOffset; // mesh offset
    SNativeInt VertexBufferOffset; 
    SNativeInt IndexBufferOffset;
    SNativeInt ExDataOffset;
    SSphere BoundingSphere;
    SBoundingBox BoundingBox;
    u32 Field90; // 1000, id?
    u32 Field94; // 3000
    u32 Field98; // 1, layer info?
    u32 Field9C; // 0
    u32 PrimitiveJointLinkCount;
} rModelHeader <bgcolor=0x0177e2>;

typedef struct
{
    local u64 p = FTell();
    rModelHeader Header;

    if ( Header.JointsOffset.Value > 0 )
    {
        FSeek( p + Header.JointsOffset.Value );
        rModelJoint Joints[Header.JointCount];
        SMtx44 JointLocalMtx[Header.JointCount]; // ?
        SMtx44 JointWorldMtx[Header.JointCount]; // ?
        byte BoneMap[256];
    }

    FSeek( p + Header.GroupOffset.Value );
    rModelGroup Groups[Header.GroupCount.Value];

    FSeek( p + Header.MaterialsOffset.Value );
    rModelMaterial Materials[Header.MaterialCount];

    FSeek( p + Header.PrimitiveOffset.Value );
    rModelPrimitive Primitives[Header.PrimitiveCount];
    rModelPrimitiveJointLink PrimitiveJointLinks[Header.PrimitiveJointLinkCount];

    FSeek( p + Header.VertexBufferOffset.Value );
    byte VertexBuffer[ Header.VertexBufferSize ] <bgcolor=0x17e9aa>;

    // always 2 bytes
    FSeek( p + Header.IndexBufferOffset.Value );
    ushort IndexBuffer[ Header.IndexCount ] <bgcolor=0xf8c956>;

    FSeek( p + Header.ExDataOffset.Value );
    u32 ExDataPresent;
    if ( ExDataPresent )
    {
        // based on the code, havent seen it in files yet
        u16 ExCount1;
        u16 ExCount2;
        u32 ExPrimValues[Header.PrimitiveCount];
        u32 ExVertexBufferSize;
        u8 ExVertexBuffer[ExVertexBufferSize];
        u32 ExVertexBuffer2Size;
        u8 ExVertexBuffer2[ExVertexBuffer2Size];
    }
} rModel <bgcolor=0xb33057>;

rModel File;